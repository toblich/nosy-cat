import { redis, logger, ComponentMetrics } from "helpers";
import * as Redlock from "redlock";

import { EWMA, EWMAStdDeviation } from "./ewma";

const MIN_IN_MS = 60000; // 1 min in milliseconds
const DELIM = ":";
const TTL_BUFFER = 60 * 10; // 10 mins
const TTL_LOCKS = 1000; // in ms, as this is for redlock and not plain redis
const TTL_EWMAS = 60 * 60 * 24; // hold learnt metrics history for up to a day

const host = process.env.REDIS_HOST || "localhost";
const bufferRedisClient = redis.createClient({ host, db: 0 });
const ewmaRedisClient = redis.createClient({ host, db: 1 });

// using special client for locks as it only really the host is relevant, and it seems
// better to use a separate DB for locks so that each DB has a consistent type (and as locks simultaneously lock
// resources in more than one DB)
const locksRedisClient = redis.createClient({ host, db: 2 });
const redlock = new Redlock([locksRedisClient], {});

const bufferFields = {
  THROUGHPUT: "throughput",
  ERRORS: "errors",
  TOTAL_MS: "total_ms",
};

const metricFields = {
  THROUGHPUT: "throughput",
  ERROR_RATE: "errorRate",
  RESPONSE_TIME: "meanResponseTimeMs",
};

interface RequestMetadata {
  component: string;
  errored: boolean;
  timestamp: number;
  duration: number;
}

interface MetricsBuffer {
  throughput: number;
  errors: number;
  total_ms: number;
}

export async function processRequest({ component, errored, timestamp, duration }: RequestMetadata): Promise<void> {
  // This `/ 1000` is because the epoch generated by zipkin is in microseconds
  const minuteTs = minuteFloor(timestamp / 1000);
  const key = buildBufferKey(component, minuteTs);

  logger.debug(`Processing request for key "${key}"`);

  await updateBuffer(key, duration, errored);

  const pattern = join(component, "*");
  const componentBufferKeys: number[] = (await (bufferRedisClient as any).keysAsync(pattern)).map(deserializeTs);
  const previousBuffersKeys = componentBufferKeys
    .filter((ts: number) => ts < minuteTs) // filter previous keys
    .sort((a: number, b: number) => a - b); // and sort temporally ascending

  for (const ts of previousBuffersKeys) {
    // cannot be done concurrently as order must be guaranteed
    await updateEWMAs(component, serializeTs(ts));
  }
}

async function updateBuffer(key: string, duration: number, errored: boolean): Promise<void> {
  const multi = bufferRedisClient.multi();
  multi.hincrby(key, bufferFields.THROUGHPUT, 1);
  multi.hincrby(key, bufferFields.TOTAL_MS, duration);
  if (errored) {
    multi.hincrby(key, "errors", 1);
  }
  multi.expire(key, TTL_BUFFER); // Set expiration to keep some (short) history

  await (multi as any).execAsync();
  logger.debug(`buffer updated for key "${key}"`);
}

type Callback = (value: number) => void;

async function updateEWMAs(component: string, bufferKey: string): Promise<void> {
  const lock = await redlock.lock(component, TTL_LOCKS);
  const buffer: MetricsBuffer | null = await (bufferRedisClient as any).hgetallAsync(bufferKey);
  if (!buffer) {
    // the buffer was empty, so it was already processed and there is nothing more to do!
    return lock.unlock();
  }

  const metrics = aggregateBuffer(buffer);
  const [ewmaKey, ewmaSquaresKey] = [buildEWMAKey(component), buildEWMASquaresKey(component)];
  const [ewmas, ewmaSquares]: ComponentMetrics[] = await Promise.all(
    [ewmaKey, ewmaSquaresKey].map((key: string) => (ewmaRedisClient as any).hgetallAsync(key))
  );

  const multi = ewmaRedisClient.multi();
  for (const field of Object.values(metricFields)) {
    const currentMeasure = metrics[field];
    const hset = (key: string): Callback => (value: number): void => {
      multi.hset(key, field, "" + value);
    };
    updateEWMA(currentMeasure, ewmas, field, hset(ewmaKey));
    updateEWMA(currentMeasure * currentMeasure, ewmaSquares, field, hset(ewmaSquaresKey));
  }
  multi.expire(ewmaKey, TTL_EWMAS);
  multi.expire(ewmaSquaresKey, TTL_EWMAS);

  try {
    await (multi as any).execAsync();
    (bufferRedisClient as any).delAsync(bufferKey).catch(logger.error); // fire-n-forget (don't await)
  } catch (error) {
    await lock.unlock();
    throw error;
  }

  return lock.unlock();
}

function updateEWMA(currentMeasure: number, ewmas: ComponentMetrics, field: string, callback: Callback): void {
  // initialize at current measure (when there's no previous EWMA)
  const currentEWMA = ewmas ? +ewmas[field] : currentMeasure;
  callback(EWMA(currentEWMA, currentMeasure));
}

export function aggregateBuffer(metrics: MetricsBuffer): ComponentMetrics {
  return {
    throughput: metrics[bufferFields.THROUGHPUT],
    meanResponseTimeMs: metrics[bufferFields.TOTAL_MS] / metrics[bufferFields.THROUGHPUT],
    errorRate: metrics[bufferFields.ERRORS] / metrics[bufferFields.THROUGHPUT],
  };
}

// --- Helper functions ---

function deserializeTs(serialized: string): number {
  return new Date(serialized).getTime(); // TODO change if serialization changes
}

function serializeTs(ts: number): string {
  return new Date(ts).toISOString(); // TODO change to use epoch as serialization mechanism for better perf overall
}

function minuteFloor(timestamp: number): number {
  return Math.floor(timestamp / MIN_IN_MS) * MIN_IN_MS; // timestamp truncated at the minute
}

function buildBufferKey(component: string, ts: number): string {
  const key = join(component, serializeTs(ts));
  logger.debug(`built key "${key}"`);
  return key;
}

function join(...args: string[]): string {
  return args.join(DELIM);
}

function buildEWMAKey(component: string): string {
  return join(component, "ewma");
}

function buildEWMASquaresKey(component: string): string {
  return join(component, "ewma_squares");
}
